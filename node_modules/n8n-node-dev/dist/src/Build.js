"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildFiles = exports.createCustomTsconfig = void 0;
const child_process_1 = require("child_process");
const copyfiles = require('copyfiles');
const fs_1 = require("fs");
const path_1 = require("path");
const tmp_promise_1 = require("tmp-promise");
const util_1 = require("util");
const fsReadFileAsync = util_1.promisify(fs_1.readFile);
const fsWriteAsync = util_1.promisify(fs_1.write);
const n8n_core_1 = require("n8n-core");
async function createCustomTsconfig() {
    const tsconfigPath = path_1.join(__dirname, '../../src/tsconfig-build.json');
    const tsConfigString = await fsReadFileAsync(tsconfigPath, { encoding: 'utf8' });
    const tsConfig = JSON.parse(tsConfigString);
    const newIncludeFiles = [];
    for (const includeFile of tsConfig.include) {
        newIncludeFiles.push(path_1.join(process.cwd(), includeFile));
    }
    tsConfig.include = newIncludeFiles;
    const { fd, path, cleanup } = await tmp_promise_1.file({ dir: process.cwd() });
    await fsWriteAsync(fd, Buffer.from(JSON.stringify(tsConfig, null, 2), 'utf8'));
    return {
        path,
        cleanup,
    };
}
exports.createCustomTsconfig = createCustomTsconfig;
async function buildFiles(options) {
    options = options || {};
    let typescriptPath;
    if (process.platform === 'win32') {
        typescriptPath = '../../node_modules/TypeScript/lib/tsc';
    }
    else {
        typescriptPath = '../../node_modules/.bin/tsc';
    }
    const tscPath = path_1.join(__dirname, typescriptPath);
    const tsconfigData = await createCustomTsconfig();
    const outputDirectory = options.destinationFolder || n8n_core_1.UserSettings.getUserN8nFolderCustomExtensionPath();
    const nodeModulesPath = path_1.join(__dirname, '../../node_modules/');
    let buildCommand = `${tscPath} --p ${tsconfigData.path} --outDir ${outputDirectory} --rootDir ${process.cwd()} --baseUrl ${nodeModulesPath}`;
    if (options.watch === true) {
        buildCommand += ' --watch';
    }
    let buildProcess;
    try {
        buildProcess = child_process_1.spawn('node', buildCommand.split(' '), { windowsVerbatimArguments: true, cwd: process.cwd() });
        buildProcess.stdout.pipe(process.stdout);
        buildProcess.stderr.pipe(process.stderr);
        process.on('exit', () => {
            buildProcess.kill();
        });
    }
    catch (error) {
        let errorMessage = error.message;
        if (error.stdout !== undefined) {
            errorMessage = `${errorMessage}\nGot following output:\n${error.stdout}`;
        }
        tsconfigData.cleanup();
        throw new Error(errorMessage);
    }
    return new Promise((resolve, reject) => {
        copyfiles([path_1.join(process.cwd(), './*.png'), outputDirectory], { up: true }, () => resolve(outputDirectory));
        buildProcess.on('exit', code => {
            tsconfigData.cleanup();
        });
    });
}
exports.buildFiles = buildFiles;
//# sourceMappingURL=Build.js.map