"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cron_1 = require("cron");
class ActiveWorkflows {
    constructor() {
        this.workflowData = {};
    }
    isActive(id) {
        return this.workflowData.hasOwnProperty(id);
    }
    allActiveWorkflows() {
        return Object.keys(this.workflowData);
    }
    get(id) {
        return this.workflowData[id];
    }
    async add(id, workflow, additionalData, getTriggerFunctions, getPollFunctions) {
        console.log('ADD ID (active): ' + id);
        this.workflowData[id] = {};
        const triggerNodes = workflow.getTriggerNodes();
        let triggerResponse;
        this.workflowData[id].triggerResponses = [];
        for (const triggerNode of triggerNodes) {
            triggerResponse = await workflow.runTrigger(triggerNode, getTriggerFunctions, additionalData, 'trigger');
            if (triggerResponse !== undefined) {
                this.workflowData[id].triggerResponses.push(triggerResponse);
            }
        }
        const pollNodes = workflow.getPollNodes();
        if (pollNodes.length) {
            this.workflowData[id].pollResponses = [];
            for (const pollNode of pollNodes) {
                this.workflowData[id].pollResponses.push(await this.activatePolling(pollNode, workflow, additionalData, getPollFunctions));
            }
        }
    }
    async activatePolling(node, workflow, additionalData, getPollFunctions) {
        const mode = 'trigger';
        const pollFunctions = getPollFunctions(workflow, node, additionalData, mode);
        const pollTimes = pollFunctions.getNodeParameter('pollTimes');
        const parameterOrder = [
            'second',
            'minute',
            'hour',
            'dayOfMonth',
            'month',
            'weekday',
        ];
        const cronTimes = [];
        let cronTime;
        let parameterName;
        if (pollTimes.item !== undefined) {
            for (const item of pollTimes.item) {
                cronTime = [];
                if (item.mode === 'custom') {
                    cronTimes.push(item.cronExpression);
                    continue;
                }
                if (item.mode === 'everyMinute') {
                    cronTimes.push(`${Math.floor(Math.random() * 60).toString()} * * * * *`);
                    continue;
                }
                if (item.mode === 'everyX') {
                    if (item.unit === 'minutes') {
                        cronTimes.push(`${Math.floor(Math.random() * 60).toString()} */${item.value} * * * *`);
                    }
                    else if (item.unit === 'hours') {
                        cronTimes.push(`${Math.floor(Math.random() * 60).toString()} 0 */${item.value} * * *`);
                    }
                    continue;
                }
                for (parameterName of parameterOrder) {
                    if (item[parameterName] !== undefined) {
                        cronTime.push(item[parameterName]);
                    }
                    else if (parameterName === 'second') {
                        cronTime.push(Math.floor(Math.random() * 60).toString());
                    }
                    else {
                        cronTime.push('*');
                    }
                }
                cronTimes.push(cronTime.join(' '));
            }
        }
        const executeTrigger = async () => {
            const pollResponse = await workflow.runPoll(node, pollFunctions);
            if (pollResponse !== null) {
                pollFunctions.__emit(pollResponse);
            }
        };
        await executeTrigger();
        const timezone = pollFunctions.getTimezone();
        const cronJobs = [];
        for (const cronTime of cronTimes) {
            cronJobs.push(new cron_1.CronJob(cronTime, executeTrigger, undefined, true, timezone));
        }
        async function closeFunction() {
            for (const cronJob of cronJobs) {
                cronJob.stop();
            }
        }
        return {
            closeFunction,
        };
    }
    async remove(id) {
        console.log('REMOVE ID (active): ' + id);
        if (!this.isActive(id)) {
            throw new Error(`The workflow with the id "${id}" is currently not active and can so not be removed`);
        }
        const workflowData = this.workflowData[id];
        if (workflowData.triggerResponses) {
            for (const triggerResponse of workflowData.triggerResponses) {
                if (triggerResponse.closeFunction) {
                    await triggerResponse.closeFunction();
                }
            }
        }
        if (workflowData.pollResponses) {
            for (const pollResponse of workflowData.pollResponses) {
                if (pollResponse.closeFunction) {
                    await pollResponse.closeFunction();
                }
            }
        }
        delete this.workflowData[id];
    }
}
exports.ActiveWorkflows = ActiveWorkflows;
//# sourceMappingURL=ActiveWorkflows.js.map