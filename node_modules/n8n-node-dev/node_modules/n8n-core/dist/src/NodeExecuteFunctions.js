"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require("./");
const n8n_workflow_1 = require("n8n-workflow");
const clientOAuth1 = require("oauth-1.0a");
const clientOAuth2 = require("client-oauth2");
const lodash_1 = require("lodash");
const path = require("path");
const requestPromise = require("request-promise-native");
const crypto_1 = require("crypto");
const file_type_1 = require("file-type");
const mime_types_1 = require("mime-types");
async function prepareBinaryData(binaryData, filePath, mimeType) {
    if (!mimeType) {
        if (filePath) {
            const mimeTypeLookup = mime_types_1.lookup(filePath);
            if (mimeTypeLookup) {
                mimeType = mimeTypeLookup;
            }
        }
        if (!mimeType) {
            const fileTypeData = await file_type_1.fromBuffer(binaryData);
            if (fileTypeData) {
                mimeType = fileTypeData.mime;
            }
        }
        if (!mimeType) {
            mimeType = 'text/plain';
        }
    }
    const returnData = {
        mimeType,
        data: binaryData.toString(_1.BINARY_ENCODING)
    };
    if (filePath) {
        if (filePath.includes('?')) {
            filePath = filePath.split('?').shift();
        }
        const filePathParts = path.parse(filePath);
        returnData.fileName = filePathParts.base;
        const fileExtension = filePathParts.ext.slice(1);
        if (fileExtension) {
            returnData.fileExtension = fileExtension;
        }
    }
    return returnData;
}
exports.prepareBinaryData = prepareBinaryData;
function requestOAuth2(credentialsType, requestOptions, node, additionalData, oAuth2Options) {
    var _a, _b, _c, _d, _e, _f, _g;
    const credentials = this.getCredentials(credentialsType);
    if (credentials === undefined) {
        throw new Error('No credentials got returned!');
    }
    if (credentials.oauthTokenData === undefined) {
        throw new Error('OAuth credentials not connected!');
    }
    const oAuthClient = new clientOAuth2({
        clientId: credentials.clientId,
        clientSecret: credentials.clientSecret,
        accessTokenUri: credentials.accessTokenUrl,
    });
    const oauthTokenData = credentials.oauthTokenData;
    const token = oAuthClient.createToken(lodash_1.get(oauthTokenData, (_a = oAuth2Options) === null || _a === void 0 ? void 0 : _a.property) || oauthTokenData.accessToken, oauthTokenData.refreshToken, ((_b = oAuth2Options) === null || _b === void 0 ? void 0 : _b.tokenType) || oauthTokenData.tokenType, oauthTokenData);
    const newRequestOptions = token.sign(requestOptions);
    if (((_c = oAuth2Options) === null || _c === void 0 ? void 0 : _c.keepBearer) === false) {
        (_e = (_d = newRequestOptions) === null || _d === void 0 ? void 0 : _d.headers) === null || _e === void 0 ? void 0 : _e.Authorization = (_g = (_f = newRequestOptions) === null || _f === void 0 ? void 0 : _f.headers) === null || _g === void 0 ? void 0 : _g.Authorization.split(' ')[1];
    }
    return this.helpers.request(newRequestOptions)
        .catch(async (error) => {
        var _a;
        if (error.statusCode === 401) {
            const tokenRefreshOptions = {};
            if ((_a = oAuth2Options) === null || _a === void 0 ? void 0 : _a.includeCredentialsOnRefreshOnBody) {
                const body = {
                    client_id: credentials.clientId,
                    client_secret: credentials.clientSecret,
                };
                tokenRefreshOptions.body = body;
            }
            const newToken = await token.refresh(tokenRefreshOptions);
            credentials.oauthTokenData = newToken.data;
            if (!node.credentials || !node.credentials[credentialsType]) {
                throw new Error(`The node "${node.name}" does not have credentials of type "${credentialsType}"!`);
            }
            const name = node.credentials[credentialsType];
            await additionalData.credentialsHelper.updateCredentials(name, credentialsType, credentials);
            const newRequestOptions = newToken.sign(requestOptions);
            return this.helpers.request(newRequestOptions);
        }
        throw error;
    });
}
exports.requestOAuth2 = requestOAuth2;
function requestOAuth1(credentialsType, requestOptions) {
    const credentials = this.getCredentials(credentialsType);
    if (credentials === undefined) {
        throw new Error('No credentials got returned!');
    }
    if (credentials.oauthTokenData === undefined) {
        throw new Error('OAuth credentials not connected!');
    }
    const oauth = new clientOAuth1({
        consumer: {
            key: credentials.consumerKey,
            secret: credentials.consumerSecret,
        },
        signature_method: credentials.signatureMethod,
        hash_function(base, key) {
            const algorithm = (credentials.signatureMethod === 'HMAC-SHA1') ? 'sha1' : 'sha256';
            return crypto_1.createHmac(algorithm, key)
                .update(base)
                .digest('base64');
        },
    });
    const oauthTokenData = credentials.oauthTokenData;
    const token = {
        key: oauthTokenData.oauth_token,
        secret: oauthTokenData.oauth_token_secret,
    };
    const newRequestOptions = {
        method: requestOptions.method,
        data: Object.assign(Object.assign({}, requestOptions.qs), requestOptions.body),
        json: requestOptions.json,
    };
    if (requestOptions.url !== undefined) {
        newRequestOptions.url = requestOptions.url;
    }
    else {
        newRequestOptions.url = requestOptions.uri;
    }
    if (requestOptions.qs !== undefined) {
        newRequestOptions.qs = oauth.authorize(newRequestOptions, token);
    }
    else {
        newRequestOptions.form = oauth.authorize(newRequestOptions, token);
    }
    return this.helpers.request(newRequestOptions)
        .catch(async (error) => {
        throw error;
    });
}
exports.requestOAuth1 = requestOAuth1;
function returnJsonArray(jsonData) {
    const returnData = [];
    if (!Array.isArray(jsonData)) {
        jsonData = [jsonData];
    }
    jsonData.forEach((data) => {
        returnData.push({ json: data });
    });
    return returnData;
}
exports.returnJsonArray = returnJsonArray;
function getCredentials(workflow, node, type, additionalData) {
    const nodeType = workflow.nodeTypes.getByName(node.type);
    if (nodeType === undefined) {
        throw new Error(`Node type "${node.type}" is not known so can not get credentials!`);
    }
    if (nodeType.description.credentials === undefined) {
        throw new Error(`Node type "${node.type}" does not have any credentials defined!`);
    }
    const nodeCredentialDescription = nodeType.description.credentials.find((credentialTypeDescription) => credentialTypeDescription.name === type);
    if (nodeCredentialDescription === undefined) {
        throw new Error(`Node type "${node.type}" does not have any credentials of type "${type}" defined!`);
    }
    if (n8n_workflow_1.NodeHelpers.displayParameter(additionalData.currentNodeParameters || node.parameters, nodeCredentialDescription, node.parameters) === false) {
        return undefined;
    }
    if (!node.credentials || !node.credentials[type]) {
        if (nodeCredentialDescription.required === true) {
            if (!node.credentials) {
                throw new Error('Node does not have any credentials set!');
            }
            if (!node.credentials[type]) {
                throw new Error(`Node does not have any credentials set for "${type}"!`);
            }
        }
        else {
            return undefined;
        }
    }
    const name = node.credentials[type];
    const decryptedDataObject = additionalData.credentialsHelper.getDecrypted(name, type);
    return decryptedDataObject;
}
exports.getCredentials = getCredentials;
function getNode(node) {
    return JSON.parse(JSON.stringify(node));
}
exports.getNode = getNode;
function getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, fallbackValue) {
    const nodeType = workflow.nodeTypes.getByName(node.type);
    if (nodeType === undefined) {
        throw new Error(`Node type "${node.type}" is not known so can not return paramter value!`);
    }
    const value = lodash_1.get(node.parameters, parameterName, fallbackValue);
    if (value === undefined) {
        throw new Error(`Could not get parameter "${parameterName}"!`);
    }
    let returnData;
    try {
        returnData = workflow.expression.getParameterValue(value, runExecutionData, runIndex, itemIndex, node.name, connectionInputData);
    }
    catch (e) {
        e.message += ` [Error in parameter: "${parameterName}"]`;
        throw e;
    }
    return returnData;
}
exports.getNodeParameter = getNodeParameter;
function continueOnFail(node) {
    return lodash_1.get(node, 'continueOnFail', false);
}
exports.continueOnFail = continueOnFail;
function getNodeWebhookUrl(name, workflow, node, additionalData, isTest) {
    let baseUrl = additionalData.webhookBaseUrl;
    if (isTest === true) {
        baseUrl = additionalData.webhookTestBaseUrl;
    }
    const webhookDescription = getWebhookDescription(name, workflow, node);
    if (webhookDescription === undefined) {
        return undefined;
    }
    const path = workflow.expression.getSimpleParameterValue(node, webhookDescription['path']);
    if (path === undefined) {
        return undefined;
    }
    const isFullPath = workflow.expression.getSimpleParameterValue(node, webhookDescription['isFullPath'], false);
    return n8n_workflow_1.NodeHelpers.getNodeWebhookUrl(baseUrl, workflow.id, node, path.toString(), isFullPath);
}
exports.getNodeWebhookUrl = getNodeWebhookUrl;
function getTimezone(workflow, additionalData) {
    if (workflow.settings !== undefined && workflow.settings.timezone !== undefined) {
        return workflow.settings.timezone;
    }
    return additionalData.timezone;
}
exports.getTimezone = getTimezone;
function getWebhookDescription(name, workflow, node) {
    const nodeType = workflow.nodeTypes.getByName(node.type);
    if (nodeType.description.webhooks === undefined) {
        return undefined;
    }
    for (const webhookDescription of nodeType.description.webhooks) {
        if (webhookDescription.name === name) {
            return webhookDescription;
        }
    }
    return undefined;
}
exports.getWebhookDescription = getWebhookDescription;
function getWorkflowMetadata(workflow) {
    return {
        id: workflow.id,
        name: workflow.name,
        active: workflow.active,
    };
}
exports.getWorkflowMetadata = getWorkflowMetadata;
function getExecutePollFunctions(workflow, node, additionalData, mode) {
    return ((workflow, node) => {
        return {
            __emit: (data) => {
                throw new Error('Overwrite NodeExecuteFunctions.getExecutePullFunctions.__emit function!');
            },
            getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData);
            },
            getMode: () => {
                return mode;
            },
            getNode: () => {
                return getNode(node);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, fallbackValue);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            helpers: {
                prepareBinaryData,
                request: requestPromise,
                requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
                returnJsonArray,
            },
        };
    })(workflow, node);
}
exports.getExecutePollFunctions = getExecutePollFunctions;
function getExecuteTriggerFunctions(workflow, node, additionalData, mode) {
    return ((workflow, node) => {
        return {
            emit: (data) => {
                throw new Error('Overwrite NodeExecuteFunctions.getExecuteTriggerFunctions.emit function!');
            },
            getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData);
            },
            getNode: () => {
                return getNode(node);
            },
            getMode: () => {
                return mode;
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, fallbackValue);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            helpers: {
                prepareBinaryData,
                request: requestPromise,
                requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
                returnJsonArray,
            },
        };
    })(workflow, node);
}
exports.getExecuteTriggerFunctions = getExecuteTriggerFunctions;
function getExecuteFunctions(workflow, runExecutionData, runIndex, connectionInputData, inputData, node, additionalData, mode) {
    return ((workflow, runExecutionData, connectionInputData, inputData, node) => {
        return {
            continueOnFail: () => {
                return continueOnFail(node);
            },
            evaluateExpression: (expression, itemIndex) => {
                return workflow.expression.resolveSimpleParameterValue('=' + expression, runExecutionData, runIndex, itemIndex, node.name, connectionInputData);
            },
            async executeWorkflow(workflowInfo, inputData) {
                return additionalData.executeWorkflow(workflowInfo, additionalData, inputData);
            },
            getContext(type) {
                return n8n_workflow_1.NodeHelpers.getContext(runExecutionData, type, node);
            },
            getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData);
            },
            getInputData: (inputIndex = 0, inputName = 'main') => {
                if (!inputData.hasOwnProperty(inputName)) {
                    return [];
                }
                if (inputData[inputName].length < inputIndex) {
                    throw new Error(`Could not get input index "${inputIndex}" of input "${inputName}"!`);
                }
                if (inputData[inputName][inputIndex] === null) {
                    throw new Error(`Value "${inputIndex}" of input "${inputName}" did not get set!`);
                }
                return inputData[inputName][inputIndex];
            },
            getNodeParameter: (parameterName, itemIndex, fallbackValue) => {
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, fallbackValue);
            },
            getMode: () => {
                return mode;
            },
            getNode: () => {
                return getNode(node);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowDataProxy: (itemIndex) => {
                const dataProxy = new n8n_workflow_1.WorkflowDataProxy(workflow, runExecutionData, runIndex, itemIndex, node.name, connectionInputData);
                return dataProxy.getDataProxy();
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            prepareOutputData: n8n_workflow_1.NodeHelpers.prepareOutputData,
            helpers: {
                prepareBinaryData,
                request: requestPromise,
                requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
                returnJsonArray,
            },
        };
    })(workflow, runExecutionData, connectionInputData, inputData, node);
}
exports.getExecuteFunctions = getExecuteFunctions;
function getExecuteSingleFunctions(workflow, runExecutionData, runIndex, connectionInputData, inputData, node, itemIndex, additionalData, mode) {
    return ((workflow, runExecutionData, connectionInputData, inputData, node, itemIndex) => {
        return {
            continueOnFail: () => {
                return continueOnFail(node);
            },
            evaluateExpression: (expression, evaluateItemIndex) => {
                evaluateItemIndex = evaluateItemIndex === undefined ? itemIndex : evaluateItemIndex;
                return workflow.expression.resolveSimpleParameterValue('=' + expression, runExecutionData, runIndex, evaluateItemIndex, node.name, connectionInputData);
            },
            getContext(type) {
                return n8n_workflow_1.NodeHelpers.getContext(runExecutionData, type, node);
            },
            getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData);
            },
            getInputData: (inputIndex = 0, inputName = 'main') => {
                if (!inputData.hasOwnProperty(inputName)) {
                    return { json: {} };
                }
                if (inputData[inputName].length < inputIndex) {
                    throw new Error(`Could not get input index "${inputIndex}" of input "${inputName}"!`);
                }
                const allItems = inputData[inputName][inputIndex];
                if (allItems === null) {
                    throw new Error(`Value "${inputIndex}" of input "${inputName}" did not get set!`);
                }
                if (allItems[itemIndex] === null) {
                    throw new Error(`Value "${inputIndex}" of input "${inputName}" with itemIndex "${itemIndex}" did not get set!`);
                }
                return allItems[itemIndex];
            },
            getMode: () => {
                return mode;
            },
            getNode: () => {
                return getNode(node);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, fallbackValue);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowDataProxy: () => {
                const dataProxy = new n8n_workflow_1.WorkflowDataProxy(workflow, runExecutionData, runIndex, itemIndex, node.name, connectionInputData);
                return dataProxy.getDataProxy();
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            helpers: {
                prepareBinaryData,
                request: requestPromise,
                requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
            },
        };
    })(workflow, runExecutionData, connectionInputData, inputData, node, itemIndex);
}
exports.getExecuteSingleFunctions = getExecuteSingleFunctions;
function getLoadOptionsFunctions(workflow, node, additionalData) {
    return ((workflow, node) => {
        const that = {
            getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData);
            },
            getCurrentNodeParameter: (parameterName) => {
                const nodeParameters = additionalData.currentNodeParameters;
                if (nodeParameters && nodeParameters[parameterName]) {
                    return nodeParameters[parameterName];
                }
                return undefined;
            },
            getCurrentNodeParameters: () => {
                return additionalData.currentNodeParameters;
            },
            getNode: () => {
                return getNode(node);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, fallbackValue);
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            helpers: {
                request: requestPromise,
                requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
            },
        };
        return that;
    })(workflow, node);
}
exports.getLoadOptionsFunctions = getLoadOptionsFunctions;
function getExecuteHookFunctions(workflow, node, additionalData, mode, isTest, webhookData) {
    return ((workflow, node) => {
        const that = {
            getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData);
            },
            getMode: () => {
                return mode;
            },
            getNode: () => {
                return getNode(node);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, fallbackValue);
            },
            getNodeWebhookUrl: (name) => {
                return getNodeWebhookUrl(name, workflow, node, additionalData, isTest);
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWebhookName() {
                if (webhookData === undefined) {
                    throw new Error('Is only supported in webhook functions!');
                }
                return webhookData.webhookDescription.name;
            },
            getWebhookDescription(name) {
                return getWebhookDescription(name, workflow, node);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            helpers: {
                request: requestPromise,
                requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
            },
        };
        return that;
    })(workflow, node);
}
exports.getExecuteHookFunctions = getExecuteHookFunctions;
function getExecuteWebhookFunctions(workflow, node, additionalData, mode, webhookData) {
    return ((workflow, node) => {
        return {
            getBodyData() {
                if (additionalData.httpRequest === undefined) {
                    throw new Error('Request is missing!');
                }
                return additionalData.httpRequest.body;
            },
            getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData);
            },
            getHeaderData() {
                if (additionalData.httpRequest === undefined) {
                    throw new Error('Request is missing!');
                }
                return additionalData.httpRequest.headers;
            },
            getMode: () => {
                return mode;
            },
            getNode: () => {
                return getNode(node);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, fallbackValue);
            },
            getQueryData() {
                if (additionalData.httpRequest === undefined) {
                    throw new Error('Request is missing!');
                }
                return additionalData.httpRequest.query;
            },
            getRequestObject() {
                if (additionalData.httpRequest === undefined) {
                    throw new Error('Request is missing!');
                }
                return additionalData.httpRequest;
            },
            getResponseObject() {
                if (additionalData.httpResponse === undefined) {
                    throw new Error('Response is missing!');
                }
                return additionalData.httpResponse;
            },
            getNodeWebhookUrl: (name) => {
                return getNodeWebhookUrl(name, workflow, node, additionalData);
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            getWebhookName() {
                return webhookData.webhookDescription.name;
            },
            prepareOutputData: n8n_workflow_1.NodeHelpers.prepareOutputData,
            helpers: {
                prepareBinaryData,
                request: requestPromise,
                requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
                returnJsonArray,
            },
        };
    })(workflow, node);
}
exports.getExecuteWebhookFunctions = getExecuteWebhookFunctions;
//# sourceMappingURL=NodeExecuteFunctions.js.map