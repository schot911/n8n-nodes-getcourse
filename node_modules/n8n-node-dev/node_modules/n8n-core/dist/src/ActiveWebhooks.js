"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require("./");
class ActiveWebhooks {
    constructor() {
        this.workflowWebhooks = {};
        this.webhookUrls = {};
        this.testWebhooks = false;
    }
    async add(workflow, webhookData, mode) {
        if (workflow.id === undefined) {
            throw new Error('Webhooks can only be added for saved workflows as an id is needed!');
        }
        const webhookKey = this.getWebhookKey(webhookData.httpMethod, webhookData.path);
        if (this.webhookUrls[webhookKey] !== undefined) {
            throw new Error(`Test-Webhook can not be activated because another one with the same method "${webhookData.httpMethod}" and path "${webhookData.path}" is already active!`);
        }
        if (this.workflowWebhooks[webhookData.workflowId] === undefined) {
            this.workflowWebhooks[webhookData.workflowId] = [];
        }
        this.webhookUrls[webhookKey] = webhookData;
        try {
            const webhookExists = await workflow.runWebhookMethod('checkExists', webhookData, _1.NodeExecuteFunctions, mode, this.testWebhooks);
            if (webhookExists === false) {
                await workflow.runWebhookMethod('create', webhookData, _1.NodeExecuteFunctions, mode, this.testWebhooks);
            }
        }
        catch (error) {
            delete this.webhookUrls[webhookKey];
            delete this.workflowWebhooks[webhookData.workflowId];
            throw error;
        }
        this.workflowWebhooks[webhookData.workflowId].push(webhookData);
    }
    get(httpMethod, path) {
        const webhookKey = this.getWebhookKey(httpMethod, path);
        if (this.webhookUrls[webhookKey] === undefined) {
            return undefined;
        }
        return this.webhookUrls[webhookKey];
    }
    getWebhookMethods(path) {
        const methods = [];
        Object.keys(this.webhookUrls)
            .filter(key => key.includes(path))
            .map(key => {
            methods.push(key.split('|')[0]);
        });
        return methods;
    }
    getWorkflowIds() {
        return Object.keys(this.workflowWebhooks);
    }
    getWebhookKey(httpMethod, path) {
        return `${httpMethod}|${path}`;
    }
    async removeWorkflow(workflow) {
        const workflowId = workflow.id.toString();
        if (this.workflowWebhooks[workflowId] === undefined) {
            return false;
        }
        const webhooks = this.workflowWebhooks[workflowId];
        const mode = 'internal';
        for (const webhookData of webhooks) {
            await workflow.runWebhookMethod('delete', webhookData, _1.NodeExecuteFunctions, mode, this.testWebhooks);
            delete this.webhookUrls[this.getWebhookKey(webhookData.httpMethod, webhookData.path)];
        }
        delete this.workflowWebhooks[workflowId];
        return true;
    }
    async removeAll(workflows) {
        const removePromises = [];
        for (const workflow of workflows) {
            removePromises.push(this.removeWorkflow(workflow));
        }
        await Promise.all(removePromises);
        return;
    }
}
exports.ActiveWebhooks = ActiveWebhooks;
//# sourceMappingURL=ActiveWebhooks.js.map